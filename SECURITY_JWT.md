# üîê Spring Security y JWT - Fintech API

---

## üìã Tabla de Contenidos

1. [¬øQu√© es Spring Security?](#qu√©-es-spring-security)
2. [¬øQu√© es JWT?](#qu√©-es-jwt)
3. [¬øC√≥mo Trabajan Juntos Spring Security y JWT?](#c√≥mo-trabajan-juntos-spring-security-y-jwt)
4. [Clases de Seguridad](#clases-de-seguridad)
5. [Implementaci√≥n Paso a Paso](#implementaci√≥n-paso-a-paso)
   - [Paso 1: Dependencias Maven](#paso-1-dependencias-maven)
   - [Paso 2: Configuraci√≥n JWT](#paso-2-configuraci√≥n-jwt)
   - [Paso 3: Crear Modelo de Datos](#paso-3-crear-modelo-de-datos)
   - [Paso 4: Crear JwtUtil](#paso-4-crear-jwtutil)
   - [Paso 5: Crear JwtAuthenticationFilter](#paso-5-crear-jwtauthenticationfilter)
   - [Paso 6: Crear UserDetailsServiceImpl](#paso-6-crear-userdetailsserviceimpl)
   - [Paso 7: Configurar SecurityConfig](#paso-7-configurar-securityconfig)
   - [Paso 8: Configurar CORS](#paso-8-configurar-cors)
   - [Paso 9: Crear AuthService](#paso-9-crear-authservice)
   - [Paso 10: Crear AuthController](#paso-10-crear-authcontroller)
   - [Paso 11: Inicializar Roles](#paso-11-inicializar-roles)
   - [Paso 12: Autorizaci√≥n con @PreAuthorize](#paso-12-autorizaci√≥n-con-preauthorize)
6. [Resumen](#resumen)

---

## üõ°Ô∏è ¬øQu√© es Spring Security?

Spring Security es un m√≥dulo del framework Spring que proporciona seguridad para aplicaciones. Ofrece:

- **Autenticaci√≥n**: Verificar la identidad del usuario (login)
- **Autorizaci√≥n**: Controlar qu√© puede hacer cada usuario (roles y permisos)
- **Protecci√≥n**: Contra ataques comunes (CSRF, XSS, etc.)

**En Fintech API:**
- Rutas p√∫blicas: `/auth/register`, `/auth/login`
- Rutas protegidas: `/accounts`, `/transactions`, `/admin/**`
- Autenticaci√≥n: JWT (tokens stateless)
- Roles: `ROLE_USER`, `ROLE_ADMIN`

---

## üé´ ¬øQu√© es JWT?

**JWT (JSON Web Token)** es un est√°ndar para transmitir informaci√≥n de forma segura entre el cliente y el servidor.

### Estructura

```
eyJhbGci...  .  eyJzdWIi...  .  SflKxwRJ...
  HEADER         PAYLOAD        SIGNATURE
```

- **Header**: Algoritmo de firma (HS256)
- **Payload**: Datos del usuario (email, nombre, customerId, expiraci√≥n)
- **Signature**: Firma criptogr√°fica para validar autenticidad

**Claims incluidos en el token:**
- `sub`: Email del usuario
- `name`: Nombre del usuario
- `customerId`: ID del Customer asociado
- `iat`: Fecha de emisi√≥n (Issued At)
- `exp`: Fecha de expiraci√≥n

### ¬øPor qu√© JWT?

- ‚úÖ **Stateless**: No requiere sesiones en servidor
- ‚úÖ **Seguro**: Firmado con clave secreta
- ‚úÖ **Escalable**: Funciona en microservicios
- ‚úÖ **Self-contained**: Contiene toda la info necesaria

**En Fintech API:**
- Expiraci√≥n: 24 horas
- Algoritmo: HMAC-SHA256
- Claims incluidos: `sub` (email), `name` (nombre), `customerId` (ID del Customer)

---

## üîó ¬øC√≥mo Trabajan Juntos Spring Security y JWT?

Spring Security y JWT se complementan para crear un sistema de autenticaci√≥n y autorizaci√≥n stateless:

### Divisi√≥n de Responsabilidades

**Spring Security se encarga de:**
- Gestionar el ciclo de autenticaci√≥n y autorizaci√≥n
- Definir qu√© rutas son p√∫blicas y cu√°les requieren autenticaci√≥n
- Mantener el contexto de seguridad (qui√©n est√° autenticado)
- Validar roles y permisos con `@PreAuthorize`
- Encriptar contrase√±as con BCrypt
- Gestionar la cadena de filtros de seguridad

**JWT se encarga de:**
- Almacenar la informaci√≥n del usuario autenticado (email, nombre, customerId)
- Viajar entre cliente y servidor en cada request
- Ser validado en cada petici√≥n sin consultar la base de datos
- Tener una fecha de expiraci√≥n autom√°tica
- No requerir almacenamiento en servidor (stateless)

### Integraci√≥n en Fintech API

1. **Al hacer login:**
   - Spring Security valida email y password contra la base de datos
   - Si es v√°lido, JWT genera un token con los datos del usuario
   - El token se retorna al cliente

2. **En cada request protegido:**
   - El cliente env√≠a el JWT en el header `Authorization: Bearer <token>`
   - Spring Security usa `JwtAuthenticationFilter` para interceptar el request
   - JWT valida el token (firma y expiraci√≥n)
   - Si es v√°lido, extrae el email del token
   - Spring Security carga el usuario completo con sus roles desde la BD (v√≠a `UserDetailsService`)
   - Spring Security establece la autenticaci√≥n en el `SecurityContext`
   - `@PreAuthorize` verifica que el usuario tenga el rol necesario
   - Si todo es v√°lido, el request llega al controller

3. **Ventajas de esta combinaci√≥n:**
   - **Stateless**: El servidor no mantiene sesiones, solo valida tokens
   - **Escalable**: Funciona en m√∫ltiples servidores sin sincronizaci√≥n
   - **Seguro**: Spring Security maneja la seguridad, JWT solo transporta datos
   - **R√°pido**: No se consulta la BD en cada request para validar el token, solo para cargar roles
   - **Flexible**: JWT puede incluir claims personalizados (customerId)

### Flujo Simplificado

**Login:**
```
Cliente ‚Üí Spring Security (valida credenciales) ‚Üí JWT (genera token) ‚Üí Cliente recibe token
```

**Request Protegido:**
```
Cliente (env√≠a JWT) ‚Üí JwtAuthenticationFilter (valida JWT) ‚Üí UserDetailsService (carga roles)
‚Üí SecurityContext (establece autenticaci√≥n) ‚Üí @PreAuthorize (verifica rol) ‚Üí Controller
```

**Resultado:**
- Spring Security controla **qui√©n** puede acceder y **qu√©** puede hacer
- JWT transporta **la identidad** del usuario de forma segura y eficiente

---

## üì¶ Clases de Seguridad

### Clases Principales

| Clase | Ubicaci√≥n | Responsabilidad |
|-------|-----------|-----------------|
| **JwtUtil** | `security/JwtUtil.java` | Genera, valida y extrae informaci√≥n de tokens JWT |
| **JwtAuthenticationFilter** | `security/JwtAuthenticationFilter.java` | Intercepta requests, valida JWT y establece autenticaci√≥n |
| **UserDetailsServiceImpl** | `security/UserDetailsServiceImpl.java` | Carga usuarios desde BD con sus roles |
| **SecurityConfig** | `config/SecurityConfig.java` | Configuraci√≥n central de seguridad (rutas, filtros) |
| **CorsConfig** | `config/CorsConfig.java` | Configuraci√≥n CORS para permitir frontend |
| **AuthService** | `service/AuthService.java` | L√≥gica de negocio para registro y login |
| **AuthController** | `controller/AuthController.java` | Endpoints REST `/auth/register` y `/auth/login` |
| **DataInitializer** | `config/DataInitializer.java` | Inicializa roles y usuario admin al arrancar |

### Modelo de Datos

| Entidad | Ubicaci√≥n | Prop√≥sito |
|---------|-----------|-----------|
| **User** | `model/User.java` | Email, password (BCrypt) y rol |
| **Role** | `model/Role.java` | Roles del sistema |
| **RoleType** | `model/RoleType.java` | Enum: `ROLE_USER`, `ROLE_ADMIN` |
| **Customer** | `model/Customer.java` | Datos personales del usuario (nombre, DNI, etc.) |

**Relaci√≥n User-Customer**: Un User (1) tiene un Customer (1). El customerId se incluye en el JWT.

---

## üöÄ Implementaci√≥n Paso a Paso

### Paso 1: Dependencias Maven

Agregar en `pom.xml`:

```xml
<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

---

### Paso 2: Configuraci√≥n JWT

En `application.properties`:

```properties
# JWT Configuration
jwt.secret=MiClaveSecretaSuperSeguraParaJWT123456789012345678901234567890
jwt.expiration=86400000  # 24 horas en milisegundos
```

‚ö†Ô∏è **Producci√≥n**: Usar variables de entorno, no hardcodear.

---

### Paso 3: Crear Modelo de Datos

#### RoleType.java
```java
public enum RoleType {
    ROLE_USER,
    ROLE_ADMIN
}
```

#### Role.java
```java
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, unique = true)
    private RoleType name;
}
```

#### User.java
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;  // BCrypt hash

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "role_id")
    private Role role;

    private Boolean active = true;
}
```

---

### Paso 4: Crear JwtUtil

**Ubicaci√≥n**: `src/main/java/com/fintech/security/JwtUtil.java`

```java
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;

    // Generar token con email, nombre y customerId
    public String generateToken(String email, String name, String customerId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
                .setSubject(email)              // Email del usuario
                .claim("name", name)            // Nombre del usuario
                .claim("customerId", customerId) // ID del Customer
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    // Extraer email del token
    public String getEmailFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);
        return claims.getSubject();
    }

    // Extraer nombre del token
    public String getNameFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);
        return claims.get("name", String.class);
    }

    // Extraer customerId del token
    public String getCustomerIdFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);
        return claims.get("customerId", String.class);
    }

    // Obtener todos los claims
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    // Validar token
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private Key getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
```

---

### Paso 5: Crear JwtAuthenticationFilter

**Ubicaci√≥n**: `src/main/java/com/fintech/security/JwtAuthenticationFilter.java`

```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && jwtUtil.validateToken(jwt)) {
                String email = jwtUtil.getEmailFromToken(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(email);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/v1/auth/") ||
               path.contains("/swagger-ui") ||
               path.contains("/v3/api-docs");
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

---

### Paso 6: Crear UserDetailsServiceImpl

**Ubicaci√≥n**: `src/main/java/com/fintech/security/UserDetailsServiceImpl.java`

```java
@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + email));

        Collection<GrantedAuthority> authorities = Collections.singletonList(
                new SimpleGrantedAuthority(user.getRole().getName().name())
        );

        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                user.getActive(),
                true, true, true,
                authorities
        );
    }
}
```

---

### Paso 7: Configurar SecurityConfig

**Ubicaci√≥n**: `src/main/java/com/fintech/config/SecurityConfig.java`

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity  // Habilita @PreAuthorize
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final CorsConfigurationSource corsConfigurationSource;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
}
```

---

### Paso 8: Configurar CORS

**Ubicaci√≥n**: `src/main/java/com/fintech/config/CorsConfig.java`

```java
@Configuration
public class CorsConfig {

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(Arrays.asList(
            "http://localhost:3000",    // React
            "http://localhost:4200"     // Angular
        ));

        configuration.setAllowedMethods(Arrays.asList(
            "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"
        ));

        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);

        return source;
    }
}
```

---

### Paso 9: Crear AuthService

**Ubicaci√≥n**: `src/main/java/com/fintech/service/AuthService.java`

```java
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final CustomerRepository customerRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    @Transactional
    public AuthResponse register(RegisterRequest request) {
        if (userRepository.existsByEmail(request.email())) {
            throw new DuplicateEmailException("Email already registered");
        }

        // Crear User
        User user = new User();
        user.setEmail(request.email());
        user.setPassword(passwordEncoder.encode(request.password()));

        Role userRole = roleRepository.findByName(RoleType.ROLE_USER)
                .orElseThrow(() -> new RoleNotFoundException("Role ROLE_USER not found"));
        user.setRole(userRole);

        User savedUser = userRepository.save(user);

        // Crear Customer asociado
        Customer customer = new Customer();
        customer.setUser(savedUser);
        customer.setName(request.name());
        customer.setPhone(request.phone());
        customer.setDni(request.dni());
        customer.setAddress(request.address());
        customer.setDateOfBirth(request.dateOfBirth());
        customer.setNationality(request.nationality());
        customer.setOccupation(request.occupation());
        Customer savedCustomer = customerRepository.save(customer);

        // Generar JWT con email, nombre y customerId
        String token = jwtUtil.generateToken(
            savedUser.getEmail(),
            savedCustomer.getName(),
            savedCustomer.getId()
        );

        return new AuthResponse(token, savedUser.getEmail(), savedCustomer.getName());
    }

    @Transactional(readOnly = true)
    public AuthResponse login(LoginRequest request) {
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        request.email(),
                        request.password()
                )
        );

        User user = userRepository.findByEmail(request.email())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        Customer customer = customerRepository.findByUserId(user.getId())
                .orElseThrow(() -> new RuntimeException("Customer not found for user"));

        // Generar JWT con email, nombre y customerId
        String token = jwtUtil.generateToken(
            user.getEmail(),
            customer.getName(),
            customer.getId()
        );

        return new AuthResponse(token, user.getEmail(), customer.getName());
    }
}
```

---

### Paso 10: Crear AuthController

**Ubicaci√≥n**: `src/main/java/com/fintech/controller/AuthController.java`

```java
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@Valid @RequestBody RegisterRequest request) {
        AuthResponse response = authService.register(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest request) {
        AuthResponse response = authService.login(request);
        return ResponseEntity.ok(response);
    }
}
```

---

### Paso 11: Inicializar Roles

**Ubicaci√≥n**: `src/main/java/com/fintech/config/DataInitializer.java`

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer implements CommandLineRunner {

    private final RoleRepository roleRepository;
    private final UserRepository userRepository;
    private final CustomerRepository customerRepository;
    private final PasswordEncoder passwordEncoder;

    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing database with default data...");

        // Crear roles
        Role userRole = createRoleIfNotExists(RoleType.ROLE_USER);
        Role adminRole = createRoleIfNotExists(RoleType.ROLE_ADMIN);

        // Crear usuario admin
        createAdminUserIfNotExists(adminRole);

        log.info("Database initialization completed.");
    }

    private Role createRoleIfNotExists(RoleType roleType) {
        return roleRepository.findByName(roleType)
                .orElseGet(() -> {
                    Role role = new Role(roleType);
                    roleRepository.save(role);
                    log.info("Created role: {}", roleType);
                    return role;
                });
    }

    private void createAdminUserIfNotExists(Role adminRole) {
        String adminEmail = "admin@fintech.com";

        if (userRepository.existsByEmail(adminEmail)) {
            log.info("Admin user already exists: {}", adminEmail);
            return;
        }

        User adminUser = new User();
        adminUser.setEmail(adminEmail);
        adminUser.setPassword(passwordEncoder.encode("admin123"));
        adminUser.setRole(adminRole);
        adminUser.setActive(true);
        User savedAdmin = userRepository.save(adminUser);

        Customer adminCustomer = new Customer();
        adminCustomer.setUser(savedAdmin);
        adminCustomer.setName("System Administrator");
        customerRepository.save(adminCustomer);

        log.info("========================================");
        log.info("DEFAULT ADMIN USER CREATED:");
        log.info("Email: {}", adminEmail);
        log.info("Password: admin123");
        log.info("‚ö†Ô∏è  CHANGE THIS PASSWORD IN PRODUCTION!");
        log.info("========================================");
    }
}
```

---

### Paso 12: Autorizaci√≥n con @PreAuthorize

#### ¬øQu√© es @PreAuthorize?

`@PreAuthorize` es una anotaci√≥n de Spring Security que permite controlar el acceso a m√©todos y clases bas√°ndose en roles. Se eval√∫a **ANTES** de ejecutar el m√©todo.

#### Habilitaci√≥n

‚ö†Ô∏è **CR√çTICO**: Para usar `@PreAuthorize`, debes habilitar `@EnableMethodSecurity` en SecurityConfig:

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity  // ‚ö†Ô∏è Sin esto, @PreAuthorize NO funciona
public class SecurityConfig {
    // ...
}
```

#### Expresiones Comunes

| Expresi√≥n | Descripci√≥n | Uso |
|-----------|-------------|-----|
| `hasRole('USER')` | Usuario tiene rol USER | `@PreAuthorize("hasRole('USER')")` |
| `hasRole('ADMIN')` | Usuario tiene rol ADMIN | `@PreAuthorize("hasRole('ADMIN')")` |
| `hasAnyRole('USER','ADMIN')` | Tiene cualquiera de esos roles | `@PreAuthorize("hasAnyRole('USER','ADMIN')")` |
| `isAuthenticated()` | Usuario est√° autenticado | `@PreAuthorize("isAuthenticated()")` |

**Nota**: Los roles en BD tienen prefijo `ROLE_` (`ROLE_USER`, `ROLE_ADMIN`), pero en `@PreAuthorize` se usa **SIN** el prefijo.

#### @PreAuthorize a Nivel de Clase (RECOMENDADO)

```java
@RestController
@RequestMapping("/accounts")
@RequiredArgsConstructor
@PreAuthorize("hasRole('USER')")  // ‚≠ê Aplica a TODOS los m√©todos
public class AccountController {

    private final AccountService accountService;

    @GetMapping
    public List<AccountResponse> getAllAccounts() {
        return accountService.getAllAccounts();
    }

    @GetMapping("/{id}")
    public AccountResponse getAccountById(@PathVariable String id) {
        return accountService.getAccountById(id);
    }

    @PostMapping
    public AccountResponse createAccount(@RequestBody AccountRequest request) {
        return accountService.createAccount(request);
    }

    // Todos los m√©todos requieren ROLE_USER autom√°ticamente
}
```

**Ventajas:**
- ‚úÖ DRY (Don't Repeat Yourself)
- ‚úÖ Menos propenso a errores
- ‚úÖ C√≥digo m√°s limpio

#### Ejemplo: Controller para Administradores

```java
@RestController
@RequestMapping("/admin/accounts")
@RequiredArgsConstructor
@PreAuthorize("hasRole('ADMIN')")  // Solo ROLE_ADMIN
public class AdminAccountController {

    private final AccountService accountService;

    // Retorna TODAS las cuentas (sin filtro de ownership)
    @GetMapping
    public List<AccountResponse> getAllAccounts() {
        return accountService.getAllAccountsAdmin();
    }

    // Puede acceder a CUALQUIER cuenta por ID
    @GetMapping("/{id}")
    public AccountResponse getAccountById(@PathVariable String id) {
        return accountService.getAccountByIdAdmin(id);
    }
}
```

#### C√≥digos de Error

| C√≥digo | Condici√≥n | Ejemplo |
|--------|-----------|---------|
| **401 Unauthorized** | JWT ausente o inv√°lido | Request sin header Authorization |
| **403 Forbidden** | JWT v√°lido pero sin rol necesario | USER intenta acceder a `/admin/accounts` |

#### Arquitectura: USER vs ADMIN

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ROLE_USER              ‚îÇ      ‚îÇ  ROLE_ADMIN              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ /accounts               ‚îÇ      ‚îÇ /admin/accounts          ‚îÇ
‚îÇ /transactions           ‚îÇ      ‚îÇ /admin/customers         ‚îÇ
‚îÇ /customer/profile       ‚îÇ      ‚îÇ /admin/transactions      ‚îÇ
‚îÇ                         ‚îÇ      ‚îÇ /admin/reports           ‚îÇ
‚îÇ ‚úÖ Con validaci√≥n       ‚îÇ      ‚îÇ /admin/settings          ‚îÇ
‚îÇ    de ownership         ‚îÇ      ‚îÇ                          ‚îÇ
‚îÇ    (solo sus recursos)  ‚îÇ      ‚îÇ ‚ùå Sin validaci√≥n        ‚îÇ
‚îÇ                         ‚îÇ      ‚îÇ    de ownership          ‚îÇ
‚îÇ                         ‚îÇ      ‚îÇ    (todos los recursos)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Mejores Pr√°cticas

1. **‚úÖ Usar @PreAuthorize a nivel de clase** cuando todos los m√©todos usan el mismo rol
2. **‚úÖ Separar controllers USER y ADMIN** en clases diferentes
3. **‚úÖ Habilitar @EnableMethodSecurity** en SecurityConfig
4. **‚úÖ Validar ownership en Service layer** para usuarios normales
5. **‚ùå NO usar @PreAuthorize en servicios**, usarlo solo en controllers

---

## ‚úÖ Resumen

**Configuraci√≥n completa:**
1. ‚úÖ Dependencias Maven agregadas (Spring Security, JJWT)
2. ‚úÖ JWT configurado en `application.properties` (secret, expiration)
3. ‚úÖ Entidades: User, Role, RoleType, Customer
4. ‚úÖ JwtUtil (generar con email/name/customerId, validar, extraer claims)
5. ‚úÖ JwtAuthenticationFilter (interceptar requests y validar JWT)
6. ‚úÖ UserDetailsServiceImpl (cargar usuarios con roles desde BD)
7. ‚úÖ SecurityConfig (rutas p√∫blicas/protegidas, @EnableMethodSecurity)
8. ‚úÖ CorsConfig (permitir frontend desde localhost:3000, localhost:4200)
9. ‚úÖ AuthService (register y login con transacciones)
10. ‚úÖ AuthController (endpoints REST)
11. ‚úÖ DataInitializer (roles ROLE_USER, ROLE_ADMIN y usuario admin)
12. ‚úÖ @PreAuthorize (control de acceso basado en roles)

**JWT Claims incluidos:**
- `sub`: Email del usuario
- `name`: Nombre del usuario
- `customerId`: ID del Customer asociado
- `iat`: Fecha de emisi√≥n
- `exp`: Fecha de expiraci√≥n (24 horas)

**Endpoints de Autenticaci√≥n:**
- `POST /api/v1/auth/register` ‚Üí Registrar usuario (crea User + Customer, retorna JWT)
- `POST /api/v1/auth/login` ‚Üí Iniciar sesi√≥n (valida credenciales, retorna JWT)

**Endpoints Protegidos:**
- `/accounts` ‚Üí Requiere `ROLE_USER` (con validaci√≥n de ownership)
- `/transactions` ‚Üí Requiere `ROLE_USER` (con validaci√≥n de ownership)
- `/customer/profile` ‚Üí Requiere `ROLE_USER` (solo su perfil)
- `/admin/**` ‚Üí Requiere `ROLE_ADMIN` (sin validaci√≥n de ownership)

**Credenciales Admin por defecto:**
- Email: `admin@fintech.com`
- Password: `admin123`
- ‚ö†Ô∏è **Cambiar en producci√≥n**

**Flujo de Autenticaci√≥n:**
1. Usuario hace POST a `/auth/login` con email y password
2. Spring Security valida las credenciales (BCrypt)
3. Si es v√°lido, genera JWT con email, nombre y customerId
4. Usuario recibe JWT en la respuesta
5. Usuario env√≠a JWT en header `Authorization: Bearer <token>` en cada request
6. JwtAuthenticationFilter valida el JWT en cada request
7. @PreAuthorize verifica que el usuario tenga el rol necesario
8. Si tiene el rol, el controller ejecuta la l√≥gica
9. El service valida ownership (para ROLE_USER) antes de retornar datos

---

**√öltima actualizaci√≥n**: 26 de Octubre, 2025
**Versi√≥n**: 2.0.0
